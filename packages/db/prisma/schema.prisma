// Wine Club SaaS Database Schema
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== User & Authentication =====
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  name          String?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  businesses BusinessUser[]
  auditLogs  AuditLog[]
  Consumer   Consumer?
  accounts   Account[]
  sessions   Session[]

  @@map("users")
}

// NextAuth.js Required Models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ===== Business (Tenant) =====
model Business {
  id                      String   @id @default(cuid())
  name                    String
  slug                    String?  @unique // Nullable until onboarding complete
  status                  BusinessStatus @default(CREATED)
  logoUrl                 String?
  description             String?
  website                 String?
  contactEmail            String?
  contactPhone            String?
  brandColorPrimary       String?  @default("#6366f1")
  brandColorSecondary     String?
  country                 String   @default("US")
  currency                String   @default("USD")
  timeZone                String   @default("America/New_York")
  
  // Stripe Connect fields
  stripeAccountId         String?  @unique
  stripeChargesEnabled    Boolean  @default(false)
  stripeDetailsSubmitted  Boolean  @default(false)
  stripeRequirements      Json?    // currently_due, eventually_due, etc.
  stripeAccountStatus     String?  // Stripe's account.status field
  
  // State tracking
  stateTransitions        Json?    // Array of {from, to, reason, timestamp, eventId}
  lastWebhookEventId      String?  // For webhook idempotency
  onboardingAbandonedAt   DateTime?
  
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  users           BusinessUser[]
  locations       Location[]
  membershipPlans MembershipPlan[]
  members         Member[]
  transactions    Transaction[]
  payoutSummaries PayoutSummary[]
  auditLogs       AuditLog[]
  
  // New subscription models
  memberships     Membership[]
  plans           Plan[]

  @@index([slug])
  @@index([status])
  @@index([stripeAccountId])
  @@map("businesses")
}

enum BusinessStatus {
  CREATED                      // Initial state
  DETAILS_COLLECTED            // Business details form completed
  STRIPE_ACCOUNT_CREATED       // Stripe Connect account created
  STRIPE_ONBOARDING_REQUIRED   // Needs to go through Stripe onboarding
  STRIPE_ONBOARDING_IN_PROGRESS // Currently in Stripe onboarding flow
  ONBOARDING_PENDING           // Legacy: in onboarding process (will migrate to specific states)
  PENDING_VERIFICATION         // Waiting for Stripe verification
  RESTRICTED                   // Account has restrictions/requirements
  ONBOARDING_COMPLETE          // Fully onboarded and ready
  FAILED                       // Onboarding failed
  ABANDONED                    // User abandoned onboarding
  SUSPENDED                    // Account suspended
}

// ===== Business User (Join Table with Role) =====
model BusinessUser {
  id         String   @id @default(cuid())
  userId     String
  businessId String
  role       Role     @default(STAFF)
  createdAt  DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  business Business @relation(fields: [businessId], references: [id], onDelete: Cascade)

  @@unique([userId, businessId])
  @@index([businessId])
  @@index([userId])
  @@map("business_users")
}

enum Role {
  OWNER
  ADMIN
  STAFF
}

// ===== Location (Optional for v1) =====
model Location {
  id         String   @id @default(cuid())
  businessId String
  name       String
  address1   String?
  address2   String?
  city       String?
  state      String?
  postalCode String?
  country    String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  business Business @relation(fields: [businessId], references: [id], onDelete: Cascade)

  @@index([businessId])
  @@map("locations")
}

// ===== Membership Plans =====
model MembershipPlan {
  id              String     @id @default(cuid())
  businessId      String
  name            String
  description     String?
  status          PlanStatus @default(ACTIVE)
  benefits        Json?
  stripeProductId String?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  business      Business       @relation(fields: [businessId], references: [id], onDelete: Cascade)
  prices        Price[]
  subscriptions Subscription[]

  @@index([businessId])
  @@index([status])
  @@map("membership_plans")
}

enum PlanStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

// ===== Price =====
model Price {
  id               String   @id @default(cuid())
  membershipPlanId String
  nickname         String?
  interval         Interval
  unitAmount       Int // cents
  currency         String   @default("USD")
  trialDays        Int?
  stripePriceId    String?
  isDefault        Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  membershipPlan MembershipPlan @relation(fields: [membershipPlanId], references: [id], onDelete: Cascade)
  subscriptions  Subscription[]

  @@index([membershipPlanId])
  @@index([stripePriceId])
  @@map("prices")
}

enum Interval {
  month
  year
}

// ===== Consumer (End User / Member) =====
model Consumer {
  id        String   @id @default(cuid())
  userId    String?  @unique
  email     String   @unique
  name      String?
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user              User?               @relation(fields: [userId], references: [id], onDelete: SetNull)
  members           Member[]
  paymentMethods    PaymentMethod[]
  transactions      Transaction[]
  planSubscriptions PlanSubscription[]  // New subscription models

  @@index([email])
  @@map("consumers")
}

// ===== Member (Business-Consumer relationship) =====
model Member {
  id         String       @id @default(cuid())
  businessId String
  consumerId String
  status     MemberStatus @default(ACTIVE)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  business      Business       @relation(fields: [businessId], references: [id], onDelete: Cascade)
  consumer      Consumer       @relation(fields: [consumerId], references: [id], onDelete: Cascade)
  subscriptions Subscription[]

  @@unique([businessId, consumerId])
  @@index([businessId])
  @@index([consumerId])
  @@index([status])
  @@index([updatedAt])
  @@index([businessId, status, updatedAt])
  @@map("members")
}

enum MemberStatus {
  ACTIVE
  PAST_DUE
  CANCELED
}

// ===== Subscription =====
model Subscription {
  id                   String             @id @default(cuid())
  memberId             String
  membershipPlanId     String
  priceId              String
  stripeSubscriptionId String             @unique
  currentPeriodEnd     DateTime
  status               SubscriptionStatus
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  member         Member         @relation(fields: [memberId], references: [id], onDelete: Cascade)
  membershipPlan MembershipPlan @relation(fields: [membershipPlanId], references: [id])
  price          Price          @relation(fields: [priceId], references: [id])
  transactions   Transaction[]

  @@index([memberId])
  @@index([stripeSubscriptionId])
  @@index([status])
  @@map("subscriptions")
}

enum SubscriptionStatus {
  active
  trialing
  past_due
  canceled
  unpaid
  incomplete
  incomplete_expired
  paused
}

// ===== Payment Method =====
model PaymentMethod {
  id                     String   @id @default(cuid())
  consumerId             String
  stripePaymentMethodId  String   @unique
  brand                  String?
  last4                  String?
  expMonth               Int?
  expYear                Int?
  isDefault              Boolean  @default(false)
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  consumer Consumer @relation(fields: [consumerId], references: [id], onDelete: Cascade)

  @@index([consumerId])
  @@map("payment_methods")
}

// ===== Transaction =====
model Transaction {
  id                     String          @id @default(cuid())
  businessId             String
  consumerId             String
  subscriptionId         String?
  amount                 Int // cents
  currency               String
  type                   TransactionType
  stripePaymentIntentId  String?
  stripeChargeId         String?
  createdAt              DateTime        @default(now())

  business     Business      @relation(fields: [businessId], references: [id], onDelete: Cascade)
  consumer     Consumer      @relation(fields: [consumerId], references: [id], onDelete: Cascade)
  subscription Subscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  @@index([businessId])
  @@index([consumerId])
  @@index([subscriptionId])
  @@index([createdAt])
  @@map("transactions")
}

enum TransactionType {
  CHARGE
  REFUND
  PAYOUT_FEE
}

// ===== Payout Summary =====
model PayoutSummary {
  id          String   @id @default(cuid())
  businessId  String
  periodStart DateTime
  periodEnd   DateTime
  gross       Int // cents
  fees        Int // cents
  net         Int // cents
  createdAt   DateTime @default(now())

  business Business @relation(fields: [businessId], references: [id], onDelete: Cascade)

  @@index([businessId])
  @@index([periodStart, periodEnd])
  @@map("payout_summaries")
}

// ===== Webhook Event =====
model WebhookEvent {
  id              String   @id @default(cuid())
  type            String
  receivedAt      DateTime @default(now())
  body            Json
  signatureValid  Boolean  @default(false)
  accountId       String?
  processed       Boolean  @default(false)
  processingError String?

  @@index([type])
  @@index([accountId])
  @@index([receivedAt])
  @@map("webhook_events")
}

// ===== Audit Log =====
model AuditLog {
  id           String   @id @default(cuid())
  businessId   String
  actorUserId  String?
  type         String
  metadata     Json?
  createdAt    DateTime @default(now())

  business Business @relation(fields: [businessId], references: [id], onDelete: Cascade)
  actor    User?    @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([businessId])
  @@index([actorUserId])
  @@index([createdAt])
  @@map("audit_logs")
}

// =====================================================
// NEW SUBSCRIPTION MODELS (Phase 1)
// Per mission.subscription-modeling.md
// Side-by-side with existing models for safe migration
// =====================================================

// ===== Membership (Collection of Plans) =====
model Membership {
  id                  String              @id @default(cuid())
  businessId          String
  
  // Core
  name                String
  description         String?
  slug                String              @unique
  
  // Rules
  allowMultiplePlans  Boolean             @default(false)  // Can member subscribe to multiple plans?
  maxMembers          Int?                                // Capacity limit
  
  // Billing Settings (MEMBERSHIP LEVEL)
  billingAnchor       BillingAnchor       @default(IMMEDIATE)
  cohortBillingDay    Int?                                // 1-31, required if NEXT_INTERVAL
  
  // Status
  status              MembershipStatus    @default(DRAFT)
  displayOrder        Int                 @default(0)
  
  // Features
  giftEnabled         Boolean             @default(true)
  waitlistEnabled     Boolean             @default(false)
  membersOnlyAccess   Boolean             @default(false)
  
  // Member Experience
  pauseEnabled        Boolean             @default(false) // Can members pause?
  skipEnabled         Boolean             @default(false) // Can members skip?
  
  // Metadata
  benefits            Json?                               // Array of benefit strings
  images              Json?                               // Array of image URLs
  
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  
  business            Business            @relation(fields: [businessId], references: [id], onDelete: Cascade)
  plans               Plan[]
  
  @@index([businessId, status])
  @@map("memberships")
}

enum BillingAnchor {
  IMMEDIATE       // Start immediately, bill on anniversary
  NEXT_INTERVAL   // Start at next cohort date, bill with cohort
}

enum MembershipStatus {
  DRAFT
  ACTIVE
  PAUSED
  ARCHIVED
}

// ===== Plan (Individual Subscription Offering) =====
model Plan {
  id                  String              @id @default(cuid())
  businessId          String
  membershipId        String              // Required - each plan belongs to ONE membership
  
  // Core
  name                String
  description         String?
  images              Json?               // Array of image URLs
  
  // Pricing
  pricingType         PricingType         @default(FIXED)
  basePrice           Int?                // In cents (for fixed pricing)
  currency            String              @default("usd")
  
  // Subscription Details (PLAN LEVEL - each plan sets its own frequency)
  interval            PriceInterval       // week, month, year
  intervalCount       Int                 @default(1)  // every 1, 2, 3, etc.
  
  // Product Details
  quantityPerShipment Int?
  productType         String?             // "wine", "beer", etc.
  
  // Fees & Shipping
  setupFee            Int?                // In cents
  shippingType        ShippingType        @default(INCLUDED)
  shippingCost        Int?                // In cents
  
  // Trial & Commitment
  trialPeriodDays     Int?
  minimumCommitmentMonths Int?
  
  // Inventory
  stockStatus         StockStatus         @default(AVAILABLE)
  maxSubscribers      Int?
  
  // Status
  status              PlanStatus          @default(DRAFT)
  displayOrder        Int                 @default(0)
  
  // Stripe
  stripeProductId     String?             @unique
  stripePriceId       String?             // Current active price
  
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  
  business            Business            @relation(fields: [businessId], references: [id], onDelete: Cascade)
  membership          Membership          @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  priceQueue          PriceQueueItem[]
  planSubscriptions   PlanSubscription[]
  
  @@index([membershipId, status])
  @@index([businessId, status])
  @@map("plans")
}

enum PricingType {
  FIXED
  DYNAMIC
}

enum PriceInterval {
  WEEK
  MONTH
  YEAR
}

enum ShippingType {
  INCLUDED
  FLAT_RATE
  CALCULATED
  FREE_OVER_AMOUNT
}

enum StockStatus {
  AVAILABLE
  SOLD_OUT
  COMING_SOON
  WAITLIST
}

// Note: PlanStatus enum already exists (lines 195-198), reusing it

// ===== PlanSubscription (Member's Subscription to a Plan) =====
// STRIPE-NATIVE: Minimal model, Stripe is source of truth
model PlanSubscription {
  id                   String   @id @default(cuid())
  planId               String
  consumerId           String   // The member/customer (links to Consumer)
  
  // === STRIPE INTEGRATION (Source of Truth) ===
  stripeSubscriptionId String   @unique
  stripeCustomerId     String
  
  // === CACHED from Stripe (updated via webhooks) ===
  // Use String to match Stripe exactly: "active", "trialing", "past_due", "canceled", "unpaid", "incomplete", "paused"
  status               String   // Mirror Stripe's status exactly
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean  @default(false)
  
  // === BUSINESS LOGIC (Not in Stripe) ===
  preferences          Json?    // Member preferences (wine type, allergies, etc.)
  giftFrom             String?  // If gift subscription
  giftMessage          String?
  
  // === METADATA ===
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  lastSyncedAt         DateTime @default(now())
  
  plan                 Plan     @relation(fields: [planId], references: [id], onDelete: Cascade)
  consumer             Consumer @relation(fields: [consumerId], references: [id], onDelete: Cascade)
  
  @@index([stripeSubscriptionId])
  @@index([consumerId, status])
  @@index([planId, status])
  @@map("plan_subscriptions")
}

// Note: No enum for PlanSubscriptionStatus - we use String to match Stripe exactly
// This allows Stripe to add new statuses without breaking our code

// ===== PriceQueueItem (For Dynamic Pricing) =====
model PriceQueueItem {
  id                  String   @id @default(cuid())
  planId              String
  
  effectiveAt         DateTime // When this price takes effect
  price               Int      // In cents
  
  // Notification tracking (DECISION: Email 7 days + 1 day before)
  notifiedAt7Days     DateTime?
  notifiedAt1Day      DateTime?
  applied             Boolean  @default(false)
  
  stripePriceId       String?  // Created price in Stripe
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  plan                Plan     @relation(fields: [planId], references: [id], onDelete: Cascade)
  
  @@index([planId, effectiveAt])
  @@map("price_queue_items")
}

